# -*- coding: utf-8 -*-
"""
Created on Thu Feb 27 23:23:39 2020

@author: Matt
"""

from wasserplan import Pair
# Python tools for output, directory management, and graph management
from functools import partial
import geopandas as gpd
from networkx import is_connected, connected_components


#gerry chain tools
from gerrychain import (
    Election,
    Graph,
    MarkovChain,
    Partition,
    accept,
    constraints,
    updaters,
)
from gerrychain.metrics import efficiency_gap, mean_median
from gerrychain.proposals import recom, propose_random_flip
from gerrychain.updaters import cut_edges, Tally
from gerrychain.constraints import contiguous
from gerrychain.accept import always_accept

def getChain(length):
    """Runs a Recom chain of the desired length, and returns the resulting
    partitions."""


    graph = Graph.from_file("./Data/Wisconsin/WI_ltsb_corrected_final.shp")

    islands = graph.islands
    components = list(connected_components(graph))
    df = gpd.read_file("./Data/Wisconsin/WI_ltsb_corrected_final.shp")
    df.to_crs({"init": "epsg:26986"}, inplace=True)


    biggest_component_size = max(len(c) for c in components)
    problem_components = [c for c in components if len(c) != biggest_component_size]
    problem_nodes = [node for component in problem_components for node in component]
    problem_geoids = [graph.nodes[node]["GEOID10"] for node in problem_nodes]

    is_a_problem = df["GEOID10"].isin(problem_geoids)

    largest_component_size = max(len(c) for c in components)
    to_delete = [c for c in components if len(c) != largest_component_size]
    for c in to_delete:
        for node in c:
            graph.remove_node(node)


    election = Election("PRETOT16", {"Dem": "PREDEM16", "Rep": "PREREP16"})
    #Create initial parition based on congressional districts
    initial_partition = Partition(
        graph,
        assignment="CON",
        updaters={
            "cut_edges": cut_edges,
            "population": Tally("PERSONS", alias="population"),
            "PRETOT16": election
            }
        )

    my_updaters = {"population": Tally("PERSONS", alias="population"), "PRETOT16": election}
    ideal_population = sum(initial_partition["population"].values()) / len(initial_partition)

    pop_constraint = constraints.within_percent_of_ideal_population(initial_partition, 0.06)

    # We use functools.partial to bind the extra parameters (pop_col, pop_target, epsilon, node_repeats)
    # of the recom proposal.
    proposal = partial(recom,
                       pop_col="PERSONS",
                       pop_target=ideal_population,
                       epsilon=0.06,
                       node_repeats=2
                       )
    compactness_bound = constraints.UpperBound(
        lambda p: len(p["cut_edges"]),
        2*len(initial_partition["cut_edges"])
        )

    chainRecom = MarkovChain(
        proposal=proposal,
        constraints=[
            pop_constraint,
            compactness_bound,
            contiguous
            ],
        accept=accept.always_accept,
        initial_state=initial_partition,
        total_steps=length
        )
    recomPlans = []
    for partition in chainRecom:
        recomPlans.append(partition)

    return recomPlans

def getGerryPlans(length, gerry_cutoff, electionName, electionStatistic="seats"):
    """Returns between 4 diverse gerrymandered plans, including the most
    gerrymandered partitions generated by a chain for each party, as well as
    an additional plan gerrymandered for each party which is determined to be
    sufficiently distant under the Wasserstein distance."""

    plans = getChain(length)

    # Sort distribution according to desired election statistic:
    if (electionStatistic=="seatsDem" or electionStatistic=="wonDem"):
        plans.sort(key=lambda x: x[electionName].seats("Dem"))
    elif (electionStatistic=="seatsRep" or electionStatistic=="wonRep"):
        plans.sort(key=lambda x: x[electionName].seats("Rep"))
    elif (electionStatistic=="efficiency_gap"):
        plans.sort(key=lambda x: x[electionName].efficiency_gap())
    elif (electionStatistic=="mean_median"):
        plans.sort(key=lambda x: x[electionName].mean_median())
    elif (electionStatistic=="mean_thirdian"):
        plans.sort(key=lambda x: x[electionName].mean_thirdian())
    elif (electionStatistic=="partisan_bias"):
        plans.sort(key=lambda x: x[electionName].partisan_bias())
    elif (electionStatistic=="partisan_gini"):
        plans.sort(key=lambda x: x[electionName].partisan_gini())

    # Initialize list to the most gerrymandered plans for each party
    gerryPlans = [plans[0], plans[-1]]

    #
    i = int(len(plans)*gerry_cutoff)
    mid = len(plans) // 2

    # Smallest known distance between plan at index 0 and a plan which is not
    # gerrymandered
    lowToNotGerryDist = float('inf')
    # Largest known distance between plan at index 0 and a plan which is
    # gerrymandered for the same party
    lowToGerryMax = float('-inf')
    # Smallest known distance between plan at index -1 and a plan which is not
    # gerrymandered
    highToNotGerryDist = float('inf')
    # Largest known distance between plan at index -1 and a plan which is
    # gerrymandered for the same party
    highToGerryMax = float('-inf')

    lowGerryMax = None
    highGerryMax = None

    changeMid = True
    while i > 0:
        if changeMid:
            lowToNotGerryDist = min(lowToNotGerryDist, Pair(plans[0], plans[mid]).distance)
        currDist = Pair(plans[0], plans[i]).distance
        if (currDist > lowToGerryMax):
            lowToGerryMax = currDist
            lowGerryMax = plans[i]
        if lowToGerryMax >= lowToNotGerryDist:
            gerryPlans.append(plans[i])
            break
        else:
            changeMid = not changeMid
            if changeMid:
                if mid > int(len(plans)*gerry_cutoff):
                    mid -= 1
                else:
                    break
            else:
                i -= 1

    j = int(len(plans)*(1-gerry_cutoff))
    changeMid = True
    mid = len(plans) // 2
    while j < len(plans)-1:
        if changeMid:
            highToNotGerryDist = min(highToNotGerryDist, Pair(plans[-1], plans[mid]).distance)
        highToGerryMax = max(highToGerryMax, Pair(plans[-1], plans[j]).distance)
        if highToGerryMax >= highToNotGerryDist:
            gerryPlans.append(plans[j])
            break
        else:
            changeMid = not changeMid
            if changeMid:
                if mid < int(len(plans)*(1-gerry_cutoff)):
                    mid += 1
                else:
                    break
            else:
                j += 1

    return gerryPlans

#print(len(getGerryPlans(1200, 0.01)))




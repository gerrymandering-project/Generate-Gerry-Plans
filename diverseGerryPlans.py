# -*- coding: utf-8 -*-
"""
Created on Tue Apr 28 21:21:23 2020

@author: Matt
"""

from wasserplan import Pair
# Python tools for output, directory management, and graph management
from functools import partial
import geopandas as gpd
from networkx import is_connected, connected_components


#gerry chain tools
from gerrychain import (
    Election,
    Graph,
    MarkovChain,
    Partition,
    accept,
    constraints,
    updaters,
)
from gerrychain.metrics import efficiency_gap, mean_median
from gerrychain.proposals import recom, propose_random_flip
from gerrychain.updaters import cut_edges, Tally
from gerrychain.constraints import contiguous
from gerrychain.accept import always_accept

def getDistribution(chain, electionName, electionStatistic="seats", party="Rep",
                    constraintFunction=(lambda x, y: True)):
    """Runs chain and returns (election statistic, plan) pairs
    
    Parameters:
    chain (MarkovChain): chain to be run
    electionName (String): name of election to determine election statistic
    electionStatistic (String): String corresponding to desired electoral statistic
    party: Party to which electoral statistic is with respect to (only applicable
           to "seats" and "wins"- else party is determined by first party listed
           in Election for chain)
    constraintFunction (function): function, which takes a plan and the index 
    in the chain as arguments, used to constrain which plans generated by chain
    are added to the distribution. By default, adds all plans.
    """
    
    plans = []
    for i, plan in enumerate(chain): # Runs chain
        # If constraintFunction is True, add appropriate tuple to list
        if (constraintFunction(plan, i)):
            if (electionStatistic=="seats" or electionStatistic=="won"):
                plans.append((plan[electionName].seats(party), plan))
            elif (electionStatistic=="efficiency_gap"):
                plans.append((plan[electionName].efficiency_gap(), plan))
            elif (electionStatistic=="mean_median"):
                plans.append((plan[electionName].mean_median(), plan))
            elif (electionStatistic=="mean_thirdian"):
                plans.append((plan[electionName].mean_thirdian(), plan))
            elif (electionStatistic=="partisan_bias"):
                plans.append((plan[electionName].partisan_bias(), plan))
            elif (electionStatistic=="partisan_gini"):
                plans.append((plan[electionName].partisan_gini(), plan))
            
    return plans
    
def diversePlans(plans, num_plans, returnMatrix=False):
    """
    Returns diverse set of plans which approximately (within a factor of 2)
    maximizes the minimum pairwise Wasserstein distance of all num_plans sized 
    subsets of plans, while making less than num_plans*len(plans) Wasserstein
    distance computations.
    
    For proof of an error factor of 2, as well as a proof of optimality, see 
    http://www.cs.utoronto.ca/~eidan/papers/huristics.pdf in combination with
    the approximation of the diameter of a point set discuessed in
    http://www.cs.tau.ac.il/~ronit/COURSES/F14sublin/LECS/Lec01_scribes.pdf
    
    Parameters:
    plans: list of Partitions to generate subset from
    num_plans (int): number of desired diverse plans to be returned
    returnMatrix (boolean): to return tuple containing distance matrix and 
    diverse indeces in addition to plans
    """

    if num_plans > len(plans):
        raise ValueError("num_plans larger than list of provided plans")
    elif num_plans == len(plans):
        return plans
    
    # Initializes distance matrix to -1's, and 0's on the diagonal
    distanceMatrix = [[-1 for j in range(len(plans))] for j in range(len(plans))]     
    for i in range(len(plans)):
        distanceMatrix[i][i] = 0
   
    # Adds first plan to diverse set:
    diverseSetIndeces = [0] # List containing indeces of diverse set
    # Add the plan which maximizes the minimum pairwise distance to current
    # diverse set to the diverse set until the desired number of plans have 
    # been found:
    while len(diverseSetIndeces) < num_plans:
        maxDist = float('-inf') # Maximum minimum pairwise distance of current loop
        maxDistIndex = -1 # Index corresponding to max distance
        for index in range(len(plans)):
            minDist = float('inf') # Minimum distance of current plan to diverse set           
            for divIndex in diverseSetIndeces:
                # Avoids repeat Wasserstein calls:
                if distanceMatrix[index][divIndex] < 0:
                    distance = Pair(plans[index], plans[divIndex]).distance
                    distanceMatrix[index][divIndex] = distance
                    distanceMatrix[divIndex][index] = distance
                minDist = min(minDist, distanceMatrix[index][divIndex])              
            if minDist > maxDist:
                maxDist = minDist
                maxDistIndex = index
                
        diverseSetIndeces.append(maxDistIndex)
    if returnMatrix:
        return [plans[index] for index in diverseSetIndeces], 
        (distanceMatrix, diverseSetIndeces)
    else:
        # Returns the actual plans:    
        return [plans[index] for index in diverseSetIndeces]
                
    

def diverseGerryPlans(chain, electionName, party=None, electionStatistic="seats", 
                      constraintFunction=(lambda x, y: True), gerry_cutoff=0.01, 
                      num_plans=5):
    """
    Returns a diverse set of plans which were generated by a certain chain and
    labelled as gerrymandered for a certain party.

    Parameters:
    chain (MarkovChain): chain to be run
    electionName (String): name of election to determine election statistic
    electionStatistic (String): String corresponding to desired electoral statistic
    party: Party to which electoral statistic is with respect to (only applicable
           to "seats" and "wins"- else party is determined by first party listed
           in Election for chain)
    constraintFunction (function): function, which takes a plan and the index 
    in the chain as arguments, used to constrain which plans generated by chain
    are added to the distribution. By default, adds all plans.
    gerry_cutoff (float): gerry_cutoff*100 is the percentage of plans labelled
    as gerrymandered for a given party
    num_plans (int): number of desired diverse plans to be returned
    """
    # Gets distribution of plans from chain, and sort in descending order according
    # to the determined election statistic
    distribution = getDistribution(chain, electionName, electionStatistic, party, 
                                   constraintFunction)
    distribution.sort(reverse=True, key=lambda x: x[0])
    # The gerrymandered plans for the given party from the distribution
    gerryPlans = [planPair[1] for planPair in distribution[:int(len(distribution)*100)]]
    return diversePlans(gerryPlans, num_plans)

if __name__ == "__main__":
    graph = Graph.from_file("./Data/Wisconsin/WI_ltsb_corrected_final.shp")

    islands = graph.islands
    components = list(connected_components(graph))
    df = gpd.read_file("./Data/Wisconsin/WI_ltsb_corrected_final.shp")
    df.to_crs({"init": "epsg:26986"}, inplace=True)


    biggest_component_size = max(len(c) for c in components)
    problem_components = [c for c in components if len(c) != biggest_component_size]
    problem_nodes = [node for component in problem_components for node in component]
    problem_geoids = [graph.nodes[node]["GEOID10"] for node in problem_nodes]

    is_a_problem = df["GEOID10"].isin(problem_geoids)

    largest_component_size = max(len(c) for c in components)
    to_delete = [c for c in components if len(c) != largest_component_size]
    for c in to_delete:
        for node in c:
            graph.remove_node(node)


    election = Election("PRETOT16", {"Dem": "PREDEM16", "Rep": "PREREP16"})
    #Create initial parition based on congressional districts
    initial_partition = Partition(
        graph,
        assignment="CON",
        updaters={
            "cut_edges": cut_edges,
            "population": Tally("PERSONS", alias="population"),
            "PRETOT16": election
            }
        )

    my_updaters = {"population": Tally("PERSONS", alias="population"), "PRETOT16": election}
    ideal_population = sum(initial_partition["population"].values()) / len(initial_partition)

    pop_constraint = constraints.within_percent_of_ideal_population(initial_partition, 0.06)

    # We use functools.partial to bind the extra parameters (pop_col, pop_target, epsilon, node_repeats)
    # of the recom proposal.
    proposal = partial(recom,
                       pop_col="PERSONS",
                       pop_target=ideal_population,
                       epsilon=0.06,
                       node_repeats=2
                       )
    compactness_bound = constraints.UpperBound(
        lambda p: len(p["cut_edges"]),
        2*len(initial_partition["cut_edges"])
        )

    chainRecom = MarkovChain(
        proposal=proposal,
        constraints=[
            pop_constraint,
            compactness_bound,
            contiguous
            ],
        accept=accept.always_accept,
        initial_state=initial_partition,
        total_steps=50
        )
    
    plans = diverseGerryPlans(chainRecom, "PRETOT16", party=None, electionStatistic="efficiency_gap", 
                      constraintFunction=(lambda x, y: True), gerry_cutoff=0.20, 
                      num_plans=3)